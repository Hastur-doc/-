#一致性检验
#%%
import numpy as np
#numpy创造数组
A=np.array([[1,2,3,5,],[1/2,1,1/2,2],[1/3,2,1,1/2],[1/5,1/2,1/2,1]])
A
#%%
#获取A的行，shape获取形状信息
n=A.shape[0]
n
#%%
#eig_val特征值,eig_vec特征向量
eig_val,eig_vec=np.linalg.eig(A)
eig_vec
#%%
Max_eig=max(eig_val)#求特征值最大值
Max_eig
#%%
CI=(Max_eig- n)/(n-1)
RI=[0,0.00001,0.52,0.89,1.12,1.26,1.36,1.41,1.46,1.49,1.52,1.54,1.56,1.58,1.59,1.5943,1.6064,1.6133,1.6207,1.6292,1.6385,1.6403,1.6462,1.6497,1.6556,1.6587,1.6631,1.667,1.6693,1.6724]#百度对RI查表得，数值为1-30阶数矩阵的RI值
#则此处RI最多接受n=30
#ps,此处n=2一定为一致矩阵，CI=0，为了防止分母为0，将RI中第二个0，调整为0.00001
CR=CI/RI[n-1]
print('一致性指标CI=',CI)
print('一致性比例CR=',CR)
if CR<0.1:
    print('因为CR<0.10，所以该判断矩阵A的一致性可以接受')
else:
    print('注意：CR>=0.10,因此该判断矩阵A需要进行修改')
#%%
#算术平均法求权重
#%%
import numpy as np
A=np.array([[1,2,3,5,],[1/2,1,1/2,2],[1/3,2,1,1/2],[1/5,1/2,1/2,1]])
#可以通过指定axis参数来计算多维数组的某个维度上的元素总和。例如，在二维数组中，axis=0表示按列计算总和,axis=1表示按行计算总和
ASum=np.sum(A,axis=0)
#获取A的行和列
n=A.shape[0]
#归一化，二维数组除以一维数组扩展为与二维数组相同的形状，然后进行逐元素的除法运算
Stand_A=A/ASum
#各列相加到同一行
ASumr=np.sum(Stand_A,axis=1)
#计算权重向量
weights=ASumr/n
print(weights)
#%%
#几何平均法求权重
#%%
import numpy as np
A=np.array([[1,2,3,5,],[1/2,1,1/2,2],[1/3,2,1,1/2],[1/5,1/2,1/2,1]])
n=A.shape[0]
#np.power计算一维数组中所有元素的乘积
#可以通过指定axis参数来计算多维数组的某个维度上的元素总和。例如，在二维数组中，axis=0表示按列计算总和,axis=1表示按行计算总和
prod_A=np.prod(A,axis=1)
#np.power,对数组中的元素进行幂运算
#np.power(a,b),对数组中a的每个元素都按照b指数进行运算
prod_n_A=np.power(prod_A,1/n)
#归一化处理
re_prod_A=prod_n_A/np.sum(prod_n_A)
#展示权重结果
print(re_prod_A)


#%%
#特征值法求权重
#%%
import numpy as np
A=np.array([[1,2,3,5,],[1/2,1,1/2,2],[1/3,2,1,1/2],[1/5,1/2,1/2,1]])
n=A.shape[0]
eig_values,eig_vectors=np.linalg.eig(A)
#求最大特征值的索引，np.argmax,返回数组中最大值的索引
max_index=np.argmax(eig_values)
#找出对应的特征向量
max_vector=eig_vectors[:,max_index]
#对特征向量进行归一化处理，得到权重
weights=max_vector/np.sum(max_vector)
#输出权重
print(weights)
